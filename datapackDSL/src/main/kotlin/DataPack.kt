import annotations.FunctionsHolder
import arguments.chatcomponents.textComponent
import arguments.types.resources.FunctionArgument
import features.advancements.Advancement
import features.chattype.ChatType
import features.damagetypes.DamageType
import features.itemmodifiers.ItemModifier
import features.loottables.LootTable
import features.predicates.Predicate
import features.recipes.RecipeFile
import features.tags.Tags
import features.worldgen.biome.Biome
import features.worldgen.configuredcarver.ConfiguredCarver
import features.worldgen.configuredfeature.ConfiguredFeature
import features.worldgen.densityfunction.DensityFunction
import features.worldgen.dimension.Dimension
import features.worldgen.dimensiontype.DimensionType
import features.worldgen.flatlevelgeneratorpreset.FlatLevelGeneratorPreset
import features.worldgen.noise.Noise
import features.worldgen.noisesettings.NoiseSettings
import features.worldgen.placedfeature.PlacedFeature
import features.worldgen.structures.Structure
import features.worldgen.structureset.StructureSet
import features.worldgen.worldpreset.WorldPreset
import functions.Function
import kotlin.io.path.Path
import pack.Features
import pack.Filter
import pack.Pack
import pack.PackMCMeta
import serializers.JsonNamingSnakeCaseStrategy
import java.io.File
import java.nio.file.Path
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

@FunctionsHolder
class DataPack(val name: String) {
	private val functions = mutableListOf<Function>()
	private val generatedFunctions = mutableListOf<Function>()

	val advancements = mutableListOf<Advancement>()
	val biomes = mutableListOf<Biome>()
	val chatTypes = mutableListOf<ChatType>()
	val configuredCarvers = mutableListOf<ConfiguredCarver>()
	val configuredFeatures = mutableListOf<ConfiguredFeature>()
	val damageTypes = mutableListOf<DamageType>()
	val densityFunctions = mutableListOf<DensityFunction>()
	val dimensions = mutableListOf<Dimension>()
	val dimensionTypes = mutableListOf<DimensionType>()
	val flatLevelGeneratorPresets = mutableListOf<FlatLevelGeneratorPreset>()
	val itemModifiers = mutableListOf<ItemModifier>()
	val lootTables = mutableListOf<LootTable>()
	val noises = mutableListOf<Noise>()
	val noiseSettings = mutableListOf<NoiseSettings>()
	val placedFeatures = mutableListOf<PlacedFeature>()
	val predicates = mutableListOf<Predicate>()
	val recipes = mutableListOf<RecipeFile>()
	val structures = mutableListOf<Structure>()
	val structureSets = mutableListOf<StructureSet>()
	val tags = mutableListOf<Tags>()
	val worldPresets = mutableListOf<WorldPreset>()

	var configuration: Configuration = Configuration.Default
	var features = Features()
	var filter: Filter? = null
	var iconPath: Path? = null
	var path = Path("out")
	val pack = Pack(15, textComponent("Generated by DataPackDSL"))

	fun addFunction(function: Function): FunctionArgument {
		functions += function
		return function
	}

	fun addGeneratedFunction(function: Function): FunctionArgument {
		generatedFunctions.find { it.lines == function.lines }?.let {
			return@addGeneratedFunction it
		}

		generatedFunctions += function
		return function
	}

	fun generate() {
		val start = System.currentTimeMillis()
		val root = File("$path/$name")
		root.mkdirs()

		val packMCMeta = generatePackMCMetaFile()
		File(root, "pack.mcmeta").writeText(packMCMeta)
		iconPath?.let { File(root, "pack.png").writeBytes(it.toFile().readBytes()) }

		val data = File(root, "data")
		data.mkdirs()

		data.generateResources("advancements", advancements)
		data.generateResources("chat_type", chatTypes)
		data.generateResources("damage_type", damageTypes)
		data.generateResources("dimensions", dimensions)
		data.generateResources("dimension_type", dimensionTypes)
		data.generateResources("item_modifiers", itemModifiers)
		data.generateResources("loot_tables", lootTables)
		data.generateResources("predicates", predicates)
		data.generateResources("recipes", recipes)
		data.generateResources("tags", tags.groupBy(Tags::namespace))
		data.generateResources("worldgen/biome", biomes)
		data.generateResources("worldgen/configured_carver", configuredCarvers)
		data.generateResources("worldgen/configured_feature", configuredFeatures)
		data.generateResources("worldgen/density_function", densityFunctions)
		data.generateResources("worldgen/flat_level_generator_preset", flatLevelGeneratorPresets)
		data.generateResources("worldgen/noise", noises)
		data.generateResources("worldgen/noise_settings", noiseSettings)
		data.generateResources("worldgen/placed_feature", placedFeatures)
		data.generateResources("worldgen/structure", structures)
		data.generateResources("worldgen/structure_set", structureSets)
		data.generateResources("worldgen/world_preset", worldPresets)

		data.generateFunctions("functions", functions.groupBy(Function::namespace))
		data.generateFunctions(
			dirName = "functions/$GENERATED_FUNCTIONS_FOLDER",
			functionsMap = generatedFunctions.map {
				it.directory = it.directory.removePrefix(GENERATED_FUNCTIONS_FOLDER)
				it
			}.groupBy(Function::namespace),
			deleteOldFiles = true
		)
		val end = System.currentTimeMillis()
		println("Generated data pack '$name' in ${end - start}ms in: ${root.absolutePath}")
	}

	fun generatePackMCMetaFile() = jsonEncoder.encodeToString(PackMCMeta(pack, features, filter))

	private fun File.generateFunctions(
		dirName: String,
		functionsMap: Map<String, List<Function>>,
		deleteOldFiles: Boolean = false,
	) =
		functionsMap.forEach { (namespace, functions) ->
			val namespaceDir = File(this, namespace)
			namespaceDir.mkdirs()

			if (functions.isEmpty()) return
			val dir = File(let { if (it.name == "data") File(it, this@DataPack.name) else it }, dirName)
			if (deleteOldFiles) dir.deleteRecursively()
			dir.mkdirs()

			functions.forEach { it.generate(dir) }
		}

	private fun <T : Generator> File.generateResources(
		dirName: String,
		resources: Map<String, List<T>>,
		deleteOldFiles: Boolean = false,
	) =
		resources.forEach { (namespace, resource) ->
			val namespaceDir = File(this, namespace)
			namespaceDir.mkdirs()

			namespaceDir.generateResources(dirName, resource, deleteOldFiles)
		}

	private fun <T : Generator> File.generateResources(
		dirName: String,
		resources: List<T>,
		deleteOldFiles: Boolean = false,
	) {
		if (resources.isEmpty()) return
		val dir = File(let { if (it.name == "data") File(it, this@DataPack.name) else it }, dirName)
		if (deleteOldFiles) dir.deleteRecursively()
		dir.mkdirs()

		resources.forEach { it.generateFile(this@DataPack, dir) }
	}

	@Deprecated(
		"Generation to zip is for now not working fine with Minecraft, please use generate() instead",
		ReplaceWith("generate()"),
		DeprecationLevel.WARNING
	)
	fun generateZip() = generate()

	@OptIn(ExperimentalSerializationApi::class)
	val jsonEncoder
		get() = Json {
			prettyPrint = configuration.prettyPrint
			if (prettyPrint) prettyPrintIndent = configuration.prettyPrintIndent
			encodeDefaults = true
			explicitNulls = false
			ignoreUnknownKeys = true
			namingStrategy = JsonNamingSnakeCaseStrategy
			useAlternativeNames = false
		}

	companion object {
		const val GENERATED_FUNCTIONS_FOLDER = "generated_scopes"
	}
}

fun dataPack(name: String, block: DataPack.() -> Unit) = DataPack(name).apply(block)

fun DataPack.configuration(block: ConfigurationBuilder.() -> Unit) {
	configuration = Configuration(block)
}
